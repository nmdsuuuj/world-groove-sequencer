# 実装順ロードマップ（非プログラマー向け）

この文書は、実際に実装してもらうときに 「どの順番で何を作ってもらうか」を整理したロードマップです。

難しいコードの話はなるべく避けて、どのフェーズで何が出来るようになるかをイメージしやすく書いています。

---

## フェーズ 0：リポジトリの骨組みを作る

### 目的

- GitHub に置ける最低限のフォルダ構成を作る。
- `docs/` と `src/` の場所だけ決めておく。

### やること

- `world-groove-sequencer` というリポジトリを作る。
- 中に以下のフォルダを作る：
  - `docs/` … 仕様書置き場
  - `src/` … 実装コード置き場
- README に「これは世界中のグルーヴを扱うシーケンサーです」と一言書く。

---

## フェーズ 1：データモデルだけ先に固める

### 目的

- シーケンサーの「頭の中の構造」を   TypeScript のインターフェースとして形にする。
- まだ音は出さない。図だけ決めるイメージ。

### やること

- `src/core/model/` に以下を作る：
  - `Pattern.ts`（Step / Ornament / OrnamentEvent を定義）
  - `Track.ts`（timeScale, swapEngineState などを持つ）
  - `LiveTake.ts`（LiveNote の配列）
  - `Song.ts`（SongStructure, TrackSegment など）
  - `Project.ts`（patterns, liveTakes, song をまとめる）
- JSON Schema（`schemas/`）は後まわしでもよいが、  できれば同時に作っておくと保存形式がブレない。

### ここまでのゴール

- 「1 パターンは 2 小節 / 32 step」「オーナメントはこういうデータ」など、  話してきた構造がコードとして固定される。

---

## フェーズ 2：最低限のシーケンサー再生ロジック

### 目的

- まだ UI は要らない。  コマンドライン or テストコードで良いので、
  - Pattern
  - Track.timeScale
  を使って **いつどのノートが鳴るか** を計算できるようにする。

### やること

- `src/core/engine/SequencerClock.ts` の枠を作る。
- ある Pattern と Track を与えたときに、
  - 「bar」と「step」を進める関数
  - オーナメントの events を展開して LiveNote を生成する関数
  を実装してもらう。

### ここまでのゴール

- 「ステップとオーナメントから、最終的なノート列が計算できる」状態。  まだ音は出ないが、配列として LiveNote が取れる。

---

## フェーズ 3：グルーヴエンジン（GrvDepth）の導入

### 目的

- LiveNote の time を、グルーヴテーブルに従ってズラす処理を追加する。
- Amapiano 的なズレなどを表現できるようにする。

### やること

- `src/core/engine/GrooveEngine.ts` を実装。
- `examples/grooves_demo.json` のような形式でグルーヴテーブルを用意。
- GrvDepth（-8〜+8 くらい）を掛けたときの挙動をテスト。

### ここまでのゴール

- 「グリッド通りの LiveNote 列」を  「変態グルーヴ付き LiveNote 列」に変換出来る。

---

## フェーズ 4：スワップエンジン（SwapEngine）

### 目的

- スワップスタイル（A〜E）とフェーダーの値に応じて、
  - アクティブなステップの並びだけを入れ替える
- 実際のアルゴリズムは段階的に作ってもらう。

### やること

- `SwapEngineState`（mode, fader）を使って、
  - `applySwap(steps, state)` を実装。
- 最初は単純な rotate（回転）だけで良い。
- 後から neighbor / block / oddloop / chaos を追加してもらう。

### ここまでのゴール

- 「ミュートされていないノートだけを対象に、  いくつかのパターンで並び替えられる」状態。

---

## フェーズ 5：Live Take の録音と再生（ロジックのみ）

### 目的

- すでにある「最終 LiveNote 列」をそのまま録音して、
  別トラックとして再生できるロジックを作る。

### やること

- LiveTake を追加・削除・再生するための API を作る：
  - `startLiveTakeRecording(trackId)`
  - `stopLiveTakeRecording()`
  - `playLiveTake(liveTakeId)`
- 録音対象は「最終 LiveNote」のみ。オートメーションは録らない。

### ここまでのゴール

- コード上で
  - パターン再生 → LiveTake に焼き付け → LiveTake を再生
  という流れが確認できる。

---

## フェーズ 6：最低限の UI（Web or ネイティブはお任せ）

### 目的

- 16step × 2 小節のグリッドを表示して、
  - ノート ON/OFF
  - オーナメント編集画面への入り口
  を作る。

### やること

- 好きな UI フレームワークで
  - シーケンサーグリッド
  - トラック選択
  - パターン選択
  を実装。
- 再生ボタンを押すと
  - 内部エンジンが LiveNote を生成
  - ソフトシンセ or 簡易ビープ音で鳴る

### ここまでのゴール

- 「ごく単純なバージョンのこのアプリ」が動き始める。

---

## フェーズ 7：ライブパフォーマンス画面の追加

### 目的

- ミュート / スワップフェーダー / オーナメントノブ / GrvDepth etc. を
  ひとつの画面にまとめる。

### やること

- チャットで決めた 3 ブロック構成（上段ボタン / 中段フェーダー / 下段ミニシーケンサー）で UI を組む。
- スワップスタイルボタン A〜E と Swap Fader を接続する。
- ノートミュートと Live Take REC/PLAY ボタンも配置。

### ここまでのゴール

- まだ荒削りでも良いので、「ライブで遊べる専用画面」が触れる。

---

## フェーズ 8：ソングモードとモザイク構成

### 目的

- パターン切り替えの履歴を SongStructure として保存し、
  - Pattern セグメント
  - LiveTake セグメント
  をモザイク状に並べられるようにする。

### やること

- SongStructure / TrackSegment を実装。
- 「ライブ中のパターン切り替え」を録音して SongStructure に変換するロジックを追加。

### ここまでのゴール

- ドラムだけ / ベースだけ / フルセット など、
  曲全体の流れをシンプルに保存出来る。

---

## フェーズ 9：プリセット・変態テンプレートの充実

### 目的

- 最初から「遊べる」状態にするため、
  - オーナメントプリセット
  - Groove パターンプリセット
  - Step Loop & Swap 組み合わせプリセット
  を用意する。

### やること

- JSON ファイルとしてプリセット集を作る。
- 起動時に読み込んでパターン一覧として表示。

### ここまでのゴール

- 何も考えず、プリセットを選んでフェーダーを触るだけで、  世界中の変態グルーヴ遊びが始まる。

---

## フェーズ 10：Android / Windows それぞれの最適化（将来）

- Android：
  - タッチ前提 / 画面サイズ別レイアウト調整
  - CPU 使用率、レイテンシ調整
- Windows：
  - マウス / キーボードショートカットの対応
  - 大画面での 2 ペイン UI など

